// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.06/01       [394753]
Creator        : kskovpen
Date           : Wed Sep 21 23:09:07 2016
Host           : Linux vocms0315.cern.ch 2.6.32-573.26.1.el6.x86_64 #1 SMP Wed May 4 09:23:05 CEST 2016 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /storage_mnt/storage/user/kskovpen/analysis/tHFCNC/CMSSW_8_0_12/src/tHFCNC/NtupleAnalyzer/test/MVA
Training events: 276663
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 12
HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB        HiggsMass_TOPTOPLEPHBB                                          'D'    [16.6172199249,500]
TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD       TopHadMass_TOPTOPLEPHAD                                         'D'    [37.9110946655,1000]
MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB              MVA_TOPTOPLEPHBB                                                'D'    [-0.838038146496,0.679038405418]
MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD              MVA_TOPTOPLEPHAD                                                'D'    [-0.867165744305,0.690195500851]
HiggsEta_TOPTOPLEPHBB         HiggsEta_TOPTOPLEPHBB         HiggsEta_TOPTOPLEPHBB         HiggsEta_TOPTOPLEPHBB                                           'D'    [-8.47341442108,7.36760616302]
TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB       TopLepMass_TOPTOPLEPHBB                                         'D'    [44.3130493164,500]
TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD       TopLepMass_TOPTOPLEPHAD                                         'D'    [53.4690132141,500]
TopLepPt_TOPTOPLEPHBB         TopLepPt_TOPTOPLEPHBB         TopLepPt_TOPTOPLEPHBB         TopLepPt_TOPTOPLEPHBB                                           'D'    [0.102413326502,1000]
TopLepEta_TOPTOPLEPHBB        TopLepEta_TOPTOPLEPHBB        TopLepEta_TOPTOPLEPHBB        TopLepEta_TOPTOPLEPHBB                                          'D'    [-8.87126636505,8.13486385345]
HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB                                         'D'    [0.395790249109,5.44797563553]
TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB    TopLepHiggsDr_TOPTOPLEPHBB                                      'D'    [0.0206876546144,10.5010242462]
TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD   TopLepTopHadDr_TOPTOPLEPHAD                                     'D'    [0.0205840077251,10.2134151459]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 12 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "HiggsMass_TOPTOPLEPHBB", "TopHadMass_TOPTOPLEPHAD", "MVA_TOPTOPLEPHBB", "MVA_TOPTOPLEPHAD", "HiggsEta_TOPTOPLEPHBB", "TopLepMass_TOPTOPLEPHBB", "TopLepMass_TOPTOPLEPHAD", "TopLepPt_TOPTOPLEPHBB", "TopLepEta_TOPTOPLEPHBB", "HiggsBJet1HiggsBJet2Dr_TOPTOPLEPHBB", "TopLepHiggsDr_TOPTOPLEPHBB", "TopLepTopHadDr_TOPTOPLEPHAD" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;

      // initialize input variable types
      fType[0] = 'D';
      fType[1] = 'D';
      fType[2] = 'D';
      fType[3] = 'D';
      fType[4] = 'D';
      fType[5] = 'D';
      fType[6] = 'D';
      fType[7] = 'D';
      fType[8] = 'D';
      fType[9] = 'D';
      fType[10] = 'D';
      fType[11] = 'D';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[12];
   double fVmax[12];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[12];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.17111661852847);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.224446, 1, 1, 0.570534,-99) , 
NN(
0, 
0, 
-1, 0.319397, 1, -1, 0.39391,-99) , 
3, 0.171075, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.109971);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.636165,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485166,-99) , 
11, 2.8517, 1, 0, 0.499505,-99) , 
3, -0.245639, 1, 0, 0.518735,-99) , 
NN(
0, 
0, 
-1, 183.771, 0, -1, 0.381132,-99) , 
3, 0.319395, 1, 0, 0.491283,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.101152);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.53925, 1, 1, 0.598093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48906,-99) , 
9, 1.60213, 1, 0, 0.505235,-99) , 
6, 223.576, 0, 0, 0.52852,-99) , 
NN(
0, 
0, 
-1, 184.091, 0, -1, 0.407388,-99) , 
3, 0.319395, 1, 0, 0.504524,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.087952);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482606,-99) , 
10, 3.39961, 1, 0, 0.521205,-99) , 
6, 308.63, 0, 0, 0.529837,-99) , 
NN(
0, 
0, 
-1, 184.091, 0, -1, 0.432018,-99) , 
3, 0.319395, 1, 0, 0.510543,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.0792917);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617921,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497192,-99) , 
2, -0.0397791, 0, 0, 0.531502,-99) , 
7, 190.956, 0, 0, 0.555501,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540586,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482929,-99) , 
11, 3.1936, 1, 0, 0.514159,-99) , 
NN(
0, 
0, 
-1, 0.361274, 1, -1, 0.466419,-99) , 
6, 181.049, 0, 0, 0.48428,-99) , 
3, -0.0514051, 1, 0, 0.505473,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.0593332);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 190.961, 0, 1, 0.591696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547085,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494066,-99) , 
2, 0.139939, 0, 0, 0.517057,-99) , 
9, 1.56752, 1, 0, 0.54798,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524285,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496439,-99) , 
5, 181.069, 0, 0, 0.507225,-99) , 
NN(
0, 
0, 
-1, 109.704, 0, -1, 0.443347,-99) , 
3, 0.354245, 1, 0, 0.495217,-99) , 
6, 202.313, 0, 0, 0.51107,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.0486368);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591167,-99) , 
NN(
NN(
0, 
0, 
-1, 190.559, 0, 1, 0.515984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509107,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451847,-99) , 
5, 184.091, 0, 0, 0.47296,-99) , 
3, 0.33293, 1, 0, 0.507737,-99) , 
6, 308.63, 0, 0, 0.513442,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0496765);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579362,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487226,-99) , 
7, 69.4057, 0, 0, 0.524797,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483976,-99) , 
1, 358.607, 0, 0, 0.490481,-99) , 
11, 2.93282, 1, 0, 0.49852,-99) , 
6, 308.63, 0, 0, 0.504031,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0508799);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55515,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523923,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483574,-99) , 
0, 98.825, 0, 0, 0.508542,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505767,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464351,-99) , 
9, 2.09015, 1, 0, 0.480736,-99) , 
0, 131.708, 1, 0, 0.502117,-99) , 
6, 266.103, 0, 0, 0.508006,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0401387);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555751,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49777,-99) , 
9, 1.72273, 1, 0, 0.518873,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485838,-99) , 
4, 1.33293, 0, 0, 0.492568,-99) , 
6, 203.794, 0, 0, 0.500027,-99) , 
9, 0.876951, 1, 0, 0.505081,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0382978);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.569209,-99) , 
NN(
NN(
0, 
0, 
-1, 244.839, 0, 1, 0.523672,-99) , 
NN(
0, 
0, 
-1, 86.0194, 0, -1, 0.489772,-99) , 
1, 212.441, 0, 0, 0.50443,-99) , 
1, 129.539, 1, 0, 0.508206,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.0336675);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 244.839, 0, 1, 0.517011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510928,-99) , 
NN(
0, 
0, 
-1, 4.38895, 1, -1, 0.481935,-99) , 
10, 3.01507, 1, 0, 0.488807,-99) , 
11, 3.41819, 1, 0, 0.508873,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0279024);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554999,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548197,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522573,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493525,-99) , 
4, -1.68441, 1, 0, 0.497566,-99) , 
6, 308.63, 0, 0, 0.501029,-99) , 
1, 129.539, 1, 0, 0.504165,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0369829);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565259,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512997,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482016,-99) , 
0, 133.002, 1, 0, 0.507741,-99) , 
6, 266.103, 0, 0, 0.512737,-99) , 
NN(
0, 
0, 
-1, 3.01674, 1, -1, 0.480571,-99) , 
2, -0.115621, 0, 0, 0.507731,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.02759);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.022755, 1, 1, 0.544752,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478258,-99) , 
3, 0.220116, 1, 0, 0.499622,-99) , 
6, 181.049, 0, 0, 0.522891,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498861,-99) , 
7, 172.42, 0, 0, 0.501098,-99) , 
NN(
0, 
0, 
-1, 118.193, 0, -1, 0.470286,-99) , 
0, 85.6719, 0, 0, 0.49668,-99) , 
7, 190.559, 0, 0, 0.503785,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0304178);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556306,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489313,-99) , 
9, 2.03621, 1, 0, 0.510482,-99) , 
11, 2.97997, 1, 0, 0.522935,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497108,-99) , 
4, -1.25297, 1, 0, 0.503101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475705,-99) , 
10, 3.97051, 1, 0, 0.500179,-99) , 
6, 202.313, 0, 0, 0.506982,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0315135);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549709,-99) , 
NN(
NN(
0, 
0, 
-1, 1.12366, 1, 1, 0.510943,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455718,-99) , 
9, 0.985613, 1, 0, 0.481734,-99) , 
0, 86.0194, 0, 0, 0.506764,-99) , 
1, 129.539, 1, 0, 0.509258,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0225067);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541897,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536015,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527644,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494554,-99) , 
9, 0.880473, 1, 0, 0.497473,-99) , 
11, 2.44745, 1, 0, 0.500113,-99) , 
1, 129.539, 1, 0, 0.502537,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0182592);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.273885, 1, 1, 0.508028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474522,-99) , 
2, -0.260104, 0, 0, 0.505915,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0137516);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529878,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526356,-99) , 
NN(
0, 
0, 
-1, 0.41475, 1, -1, 0.497062,-99) , 
3, -0.273885, 1, 0, 0.499843,-99) , 
4, 2.08727, 0, 0, 0.501926,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0182804);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534888,-99) , 
NN(
NN(
0, 
0, 
-1, 1.12366, 1, 1, 0.505796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466825,-99) , 
9, 0.985613, 1, 0, 0.482018,-99) , 
0, 86.0194, 0, 0, 0.502396,-99) , 
1, 129.539, 1, 0, 0.50428,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0271334);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530338,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49705,-99) , 
9, 1.61022, 1, 0, 0.504778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479572,-99) , 
1, 212.441, 0, 0, 0.489975,-99) , 
0, 109.018, 0, 0, 0.498537,-99) , 
1, 129.539, 1, 0, 0.50038,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0142076);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528253,-99) , 
NN(
NN(
0, 
0, 
-1, 266.103, 0, 1, 0.503689,-99) , 
NN(
0, 
0, 
-1, 320.52, 0, -1, 0.479522,-99) , 
2, -0.172173, 0, 0, 0.500968,-99) , 
11, 2.44745, 1, 0, 0.502802,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0308615);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557257,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498763,-99) , 
9, 1.81347, 1, 0, 0.522665,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4898,-99) , 
3, 0.182471, 0, 0, 0.499261,-99) , 
6, 205.133, 0, 0, 0.505996,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513869,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488036,-99) , 
2, 0.166689, 0, 0, 0.49659,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459245,-99) , 
3, 0.403652, 1, 0, 0.492172,-99) , 
0, 108.69, 0, 0, 0.499997,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0163557);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528838,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525355,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521684,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496236,-99) , 
1, 450.235, 0, 0, 0.498462,-99) , 
4, 2.08727, 0, 0, 0.500283,-99) , 
11, 2.44745, 1, 0, 0.502203,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0265098);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498693,-99) , 
9, 2.08245, 1, 0, 0.527281,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494926,-99) , 
1, 145.653, 1, 0, 0.502741,-99) , 
1, 223.919, 0, 0, 0.512072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520086,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479056,-99) , 
9, 1.57343, 0, 0, 0.493328,-99) , 
10, 2.48932, 1, 0, 0.498127,-99) , 
6, 181.049, 0, 0, 0.504604,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0255441);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.61107, 1, 1, 0.523262,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516101,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495879,-99) , 
7, 190.937, 0, 0, 0.501364,-99) , 
0, 109.018, 0, 0, 0.513695,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513466,-99) , 
NN(
0, 
0, 
-1, 0.407861, 1, -1, 0.491134,-99) , 
10, 2.48932, 1, 0, 0.495138,-99) , 
6, 181.049, 0, 0, 0.503756,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0193699);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525997,-99) , 
NN(
NN(
0, 
0, 
-1, -0.479605, 1, 1, 0.516954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513612,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495893,-99) , 
4, 1.33293, 0, 0, 0.499851,-99) , 
8, -1.58292, 1, 0, 0.502784,-99) , 
9, 0.876951, 1, 0, 0.504874,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.022885);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 190.614, 0, 1, 0.514193,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504277,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477393,-99) , 
3, 0.393555, 1, 0, 0.499892,-99) , 
11, 3.14083, 1, 0, 0.507427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481068,-99) , 
11, 4.38894, 1, 0, 0.505703,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0241329);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528764,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475884,-99) , 
9, 2.80159, 1, 0, 0.503334,-99) , 
2, 0.300738, 0, 0, 0.50807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489489,-99) , 
8, 1.51788, 0, 0, 0.492962,-99) , 
4, -1.89156, 1, 0, 0.495909,-99) , 
6, 181.049, 0, 0, 0.501556,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0302515);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 145.462, 1, 1, 0.534398,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514782,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482026,-99) , 
0, 111.772, 0, 0, 0.498866,-99) , 
1, 155.553, 1, 0, 0.508672,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496943,-99) , 
7, 238.373, 0, 0, 0.501614,-99) , 
NN(
0, 
0, 
-1, 0.114573, 1, -1, 0.474417,-99) , 
3, 0.0721935, 1, 0, 0.495493,-99) , 
3, 0.171075, 0, 0, 0.500728,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0137189);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53756,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490766,-99) , 
11, 2.65686, 1, 0, 0.500728,-99) , 
7, 143.365, 0, 0, 0.512956,-99) , 
NN(
NN(
0, 
0, 
-1, 0.86547, 1, 1, 0.501958,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480511,-99) , 
2, -0.243108, 0, 0, 0.500419,-99) , 
11, 2.93282, 1, 0, 0.503342,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0203162);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534148,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508648,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491608,-99) , 
7, 82.1604, 0, 0, 0.500569,-99) , 
7, 143.365, 0, 0, 0.511714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509807,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493288,-99) , 
8, 2.18844, 0, 0, 0.495582,-99) , 
4, -1.68441, 1, 0, 0.497481,-99) , 
11, 2.93282, 1, 0, 0.5008,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.019576);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522737,-99) , 
NN(
NN(
0, 
0, 
-1, 1.12087, 1, 1, 0.507907,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491924,-99) , 
1, 149.278, 1, 0, 0.496415,-99) , 
1, 212.441, 0, 0, 0.501377,-99) , 
1, 129.539, 1, 0, 0.502614,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0199914);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 168.92, 0, 1, 0.513167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484481,-99) , 
3, 0.442996, 1, 0, 0.508588,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497818,-99) , 
2, 0.317571, 0, 0, 0.501161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471186,-99) , 
3, 0.121633, 1, 0, 0.497772,-99) , 
3, 0.171075, 0, 0, 0.502067,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0162232);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496749,-99) , 
1, 181.655, 0, 0, 0.513946,-99) , 
NN(
NN(
0, 
0, 
-1, -0.479605, 1, 1, 0.512275,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49589,-99) , 
2, 0.324108, 0, 0, 0.498523,-99) , 
8, -1.58292, 1, 0, 0.500934,-99) , 
9, 1.11753, 1, 0, 0.503038,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0183295);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.77168, 0, 1, 0.507938,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50625,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479366,-99) , 
2, 0.13213, 0, 0, 0.491775,-99) , 
9, 2.80159, 1, 0, 0.505721,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479695,-99) , 
9, 2.5086, 0, 0, 0.490832,-99) , 
10, 4.0132, 1, 0, 0.504095,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0137396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510051,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493528,-99) , 
3, 0.151177, 0, 0, 0.499554,-99) , 
6, 204.853, 0, 0, 0.508929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510243,-99) , 
NN(
0, 
0, 
-1, 4.31961, 1, -1, 0.496398,-99) , 
10, 2.51601, 1, 0, 0.498129,-99) , 
11, 2.93282, 1, 0, 0.500647,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0147295);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521083,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530114,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496629,-99) , 
9, 1.54221, 1, 0, 0.511815,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491831,-99) , 
9, 1.60285, 0, 0, 0.499599,-99) , 
6, 244.839, 0, 0, 0.50142,-99) , 
1, 129.539, 1, 0, 0.502559,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0138442);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.739471, 1, 1, 0.512847,-99) , 
NN(
NN(
0, 
0, 
-1, 2.94334, 1, 1, 0.506872,-99) , 
NN(
0, 
0, 
-1, 102.43, 0, -1, 0.494835,-99) , 
5, 196.209, 0, 0, 0.499162,-99) , 
9, 1.11753, 1, 0, 0.501375,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0181909);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518367,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515171,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499603,-99) , 
6, 244.839, 0, 0, 0.502279,-99) , 
10, 2.51919, 1, 0, 0.504914,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499054,-99) , 
7, 113.193, 0, 0, 0.510383,-99) , 
NN(
0, 
0, 
-1, 111.215, 0, -1, 0.481231,-99) , 
1, 155.717, 1, 0, 0.496377,-99) , 
1, 175.352, 0, 0, 0.501631,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0176086);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1.12087, 1, 1, 0.506666,-99) , 
NN(
NN(
0, 
0, 
-1, 0.132414, 0, 1, 0.510372,-99) , 
NN(
0, 
0, 
-1, 111.215, 0, -1, 0.485773,-99) , 
1, 155.717, 1, 0, 0.498555,-99) , 
1, 175.352, 0, 0, 0.503546,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.016778);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521029,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520355,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494764,-99) , 
1, 150.507, 1, 0, 0.50115,-99) , 
1, 182.042, 0, 0, 0.505441,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486526,-99) , 
2, -0.260233, 0, 0, 0.500725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473937,-99) , 
3, 0.121633, 1, 0, 0.497696,-99) , 
3, 0.171075, 0, 0, 0.500771,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.01789);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514811,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495179,-99) , 
4, -1.00192, 1, 0, 0.502027,-99) , 
4, 1.33293, 0, 0, 0.506184,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490574,-99) , 
9, 2.32043, 1, 0, 0.498855,-99) , 
NN(
0, 
0, 
-1, 0.539614, 0, -1, 0.482987,-99) , 
3, 0.0721935, 1, 0, 0.495284,-99) , 
3, 0.171075, 0, 0, 0.499612,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0199914);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.93811, 0, 1, 0.519411,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496559,-99) , 
3, 0.26755, 1, 0, 0.501837,-99) , 
5, 196.209, 0, 0, 0.506325,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506973,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491833,-99) , 
9, 2.09015, 1, 0, 0.499028,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477644,-99) , 
9, 1.65831, 0, 0, 0.488749,-99) , 
0, 108.69, 0, 0, 0.494981,-99) , 
3, 0.171075, 0, 0, 0.499485,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0158364);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516927,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499997,-99) , 
0, 103.793, 0, 0, 0.50887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49135,-99) , 
0, 130.097, 1, 0, 0.506229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496245,-99) , 
6, 247.257, 0, 0, 0.499275,-99) , 
NN(
0, 
0, 
-1, 1.65831, 0, -1, 0.489433,-99) , 
0, 108.69, 0, 0, 0.495401,-99) , 
3, 0.171075, 0, 0, 0.4997,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0126433);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529954,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481032,-99) , 
5, 167.604, 0, 0, 0.499075,-99) , 
10, 3.02352, 1, 0, 0.510096,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513714,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500189,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485877,-99) , 
3, -0.245639, 0, 0, 0.498306,-99) , 
11, 2.44745, 1, 0, 0.499587,-99) , 
3, 0.319395, 0, 0, 0.501647,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0166372);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526803,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484189,-99) , 
5, 167.604, 0, 0, 0.498472,-99) , 
10, 3.02352, 1, 0, 0.508582,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50397,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493577,-99) , 
10, 3.51413, 0, 0, 0.495977,-99) , 
11, 2.44745, 1, 0, 0.497188,-99) , 
3, 0.319395, 0, 0, 0.499422,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0160034);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499877,-99) , 
8, 1.41089, 0, 0, 0.510643,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493958,-99) , 
8, -0.792132, 1, 0, 0.498952,-99) , 
4, 1.05445, 0, 0, 0.501874,-99) , 
NN(
0, 
0, 
-1, 2.5086, 0, -1, 0.488418,-99) , 
10, 4.0132, 1, 0, 0.500403,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0116903);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514562,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515837,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493633,-99) , 
11, 3.29689, 1, 0, 0.506613,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485342,-99) , 
3, -0.202318, 0, 0, 0.497879,-99) , 
2, 0.253433, 0, 0, 0.500416,-99) , 
9, 0.876951, 1, 0, 0.501688,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0152353);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511641,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496556,-99) , 
11, 3.29689, 1, 0, 0.50612,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493918,-99) , 
0, 163.195, 0, 0, 0.495808,-99) , 
2, 0.253433, 0, 0, 0.498803,-99) , 
9, 0.876951, 1, 0, 0.499957,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0100787);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514614,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512194,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497497,-99) , 
1, 146.988, 1, 0, 0.499479,-99) , 
1, 496.049, 0, 0, 0.500318,-99) , 
4, 2.08727, 0, 0, 0.501309,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.014692);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523551,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492998,-99) , 
5, 167.604, 0, 0, 0.502033,-99) , 
10, 3.02352, 1, 0, 0.50971,-99) , 
NN(
NN(
0, 
0, 
-1, 1.12087, 1, 1, 0.503357,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510783,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488077,-99) , 
1, 136.083, 1, 0, 0.495022,-99) , 
1, 175.352, 0, 0, 0.500797,-99) , 
3, 0.319395, 0, 0, 0.502544,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0109968);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516218,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499083,-99) , 
4, -1.61654, 1, 0, 0.503001,-99) , 
8, 1.39846, 0, 0, 0.505914,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501262,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493938,-99) , 
0, 108.69, 0, 0, 0.498457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485073,-99) , 
3, 0.121633, 1, 0, 0.496945,-99) , 
3, 0.171075, 0, 0, 0.500505,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0163549);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517075,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486962,-99) , 
3, 0.442996, 1, 0, 0.504043,-99) , 
4, 1.33293, 0, 0, 0.506755,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511297,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494663,-99) , 
8, 1.11224, 0, 0, 0.501012,-99) , 
NN(
0, 
0, 
-1, -0.978699, 1, -1, 0.493706,-99) , 
4, 0.378098, 0, 0, 0.496684,-99) , 
3, 0.171075, 0, 0, 0.500682,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.00813155);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514054,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498979,-99) , 
8, 2.26603, 0, 0, 0.500622,-99) , 
8, -1.93821, 1, 0, 0.501917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487533,-99) , 
10, 4.51226, 1, 0, 0.501189,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0117534);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520512,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494172,-99) , 
10, 3.37425, 1, 0, 0.502158,-99) , 
10, 3.02352, 1, 0, 0.508706,-99) , 
NN(
NN(
0, 
0, 
-1, 0.0869793, 0, 1, 0.508392,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49335,-99) , 
9, 1.73617, 0, 0, 0.499776,-99) , 
9, 1.11753, 1, 0, 0.501082,-99) , 
3, 0.319395, 0, 0, 0.502576,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0105982);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517578,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506742,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49711,-99) , 
10, 3.37425, 1, 0, 0.50207,-99) , 
10, 3.02352, 1, 0, 0.507602,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503134,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49507,-99) , 
7, 95.5684, 0, 0, 0.50052,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489659,-99) , 
3, 0.262883, 1, 0, 0.499566,-99) , 
3, 0.319395, 0, 0, 0.50114,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0130308);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513013,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488807,-99) , 
0, 76.903, 0, 0, 0.500691,-99) , 
3, 0.395331, 0, 0, 0.50225,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506355,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476511,-99) , 
0, 140.058, 1, 0, 0.489347,-99) , 
0, 166.784, 0, 0, 0.494693,-99) , 
0, 131.708, 1, 0, 0.500449,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0119437);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496872,-99) , 
4, 1.75287, 0, 0, 0.498267,-99) , 
9, 0.739475, 1, 0, 0.499538,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505653,-99) , 
NN(
0, 
0, 
-1, 0.092002, 1, -1, 0.48434,-99) , 
10, 3.51413, 0, 0, 0.491772,-99) , 
9, 2.80159, 1, 0, 0.498317,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.011152);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520097,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499868,-99) , 
7, 139.304, 0, 0, 0.508903,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497687,-99) , 
8, 2.18844, 0, 0, 0.499599,-99) , 
4, -1.23587, 1, 0, 0.501589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502667,-99) , 
NN(
0, 
0, 
-1, 0.092002, 1, -1, 0.487323,-99) , 
10, 3.51413, 0, 0, 0.492674,-99) , 
9, 2.80159, 1, 0, 0.500187,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0108941);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.03076, 0, 1, 0.50471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49279,-99) , 
10, 3.88489, 1, 0, 0.503417,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488163,-99) , 
6, 163.31, 1, 0, 0.493517,-99) , 
9, 2.80159, 1, 0, 0.50186,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.00853425);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51429,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489169,-99) , 
4, -0.714584, 1, 0, 0.500594,-99) , 
4, 0.578597, 0, 0, 0.505607,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507081,-99) , 
NN(
0, 
0, 
-1, 304.706, 1, -1, 0.498081,-99) , 
11, 2.44745, 1, 0, 0.498828,-99) , 
3, 0.319395, 0, 0, 0.500156,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.00621358);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 136.127, 1, 1, 0.502547,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490467,-99) , 
5, 183.77, 0, 0, 0.495386,-99) , 
9, 2.80159, 1, 0, 0.501421,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.00767619);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513181,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498351,-99) , 
8, 2.26603, 0, 0, 0.499513,-99) , 
8, -1.93821, 1, 0, 0.500723,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489254,-99) , 
10, 4.51226, 1, 0, 0.500142,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.00740862);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 136.192, 1, 1, 0.503057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493137,-99) , 
7, 47.7166, 0, 0, 0.502167,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49244,-99) , 
5, 304.706, 1, 0, 0.501452,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.00914335);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509406,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512987,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49121,-99) , 
2, 0.173346, 1, 0, 0.505134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493883,-99) , 
0, 125.497, 1, 0, 0.498581,-99) , 
9, 1.12087, 1, 0, 0.499613,-99) , 
1, 129.539, 1, 0, 0.50018,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0141295);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517299,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497955,-99) , 
7, 190.614, 0, 0, 0.503005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488978,-99) , 
11, 3.43799, 0, 0, 0.496633,-99) , 
11, 3.14083, 1, 0, 0.499988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49143,-99) , 
11, 4.38894, 1, 0, 0.499428,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0112024);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524656,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503735,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486989,-99) , 
1, 229.699, 1, 0, 0.497699,-99) , 
6, 204.853, 0, 0, 0.50511,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502559,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497334,-99) , 
1, 175.352, 0, 0, 0.500469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483439,-99) , 
5, 304.706, 1, 0, 0.49915,-99) , 
11, 2.93282, 1, 0, 0.500539,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.00819142);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51013,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508216,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496464,-99) , 
9, 2.32284, 0, 0, 0.498737,-99) , 
6, 308.63, 0, 0, 0.499374,-99) , 
1, 129.539, 1, 0, 0.499997,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.00680535);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512481,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499094,-99) , 
3, -0.199725, 1, 0, 0.500542,-99) , 
1, 136.127, 1, 0, 0.501471,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490423,-99) , 
2, 0.182272, 0, 0, 0.494171,-99) , 
9, 2.80159, 1, 0, 0.500323,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.00887891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513947,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502793,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491991,-99) , 
6, 138.523, 0, 0, 0.501613,-99) , 
9, 0.739475, 1, 0, 0.502429,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501634,-99) , 
NN(
0, 
0, 
-1, 0.14228, 0, -1, 0.491238,-99) , 
7, 130.803, 0, 0, 0.494601,-99) , 
9, 2.80159, 1, 0, 0.501198,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00997985);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50997,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508638,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495937,-99) , 
1, 156.814, 1, 0, 0.500757,-99) , 
1, 182.042, 0, 0, 0.502746,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488136,-99) , 
4, 1.67321, 1, 0, 0.49964,-99) , 
NN(
0, 
0, 
-1, 3.09659, 0, -1, 0.491973,-99) , 
3, 0.0721935, 1, 0, 0.497915,-99) , 
3, 0.171075, 0, 0, 0.499832,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.00884593);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513803,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49582,-99) , 
7, 149.327, 1, 0, 0.500064,-99) , 
10, 3.02352, 1, 0, 0.504965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503928,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497764,-99) , 
5, 239.607, 0, 0, 0.498976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480565,-99) , 
2, -0.0858451, 0, 0, 0.491726,-99) , 
0, 85.6719, 0, 0, 0.497888,-99) , 
3, 0.319395, 0, 0, 0.499274,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.00883006);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506423,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497506,-99) , 
7, 92.7522, 0, 0, 0.503642,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509131,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497518,-99) , 
4, -2.0077, 1, 0, 0.499105,-99) , 
4, 0.578597, 0, 0, 0.500771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491038,-99) , 
5, 304.706, 1, 0, 0.500055,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.00829663);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499476,-99) , 
1, 184.815, 0, 0, 0.502328,-99) , 
6, 204.853, 0, 0, 0.503884,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496859,-99) , 
9, 2.08462, 1, 0, 0.500112,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491746,-99) , 
0, 85.6719, 0, 0, 0.498896,-99) , 
3, 0.171075, 0, 0, 0.500876,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.00766405);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 103.793, 0, 1, 0.506204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496039,-99) , 
0, 130.097, 1, 0, 0.504673,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508547,-99) , 
NN(
0, 
0, 
-1, 289.18, 1, -1, 0.498133,-99) , 
8, -2.12575, 1, 0, 0.49911,-99) , 
3, 0.171075, 0, 0, 0.501318,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0141193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521387,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495284,-99) , 
11, 2.79414, 0, 0, 0.500599,-99) , 
6, 204.853, 0, 0, 0.506312,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505275,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495378,-99) , 
9, 1.59869, 0, 0, 0.501775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484383,-99) , 
3, -0.273885, 0, 0, 0.500332,-99) , 
11, 2.93282, 1, 0, 0.501725,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00875346);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49367,-99) , 
1, 229.699, 1, 0, 0.501706,-99) , 
6, 204.853, 0, 0, 0.506146,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499418,-99) , 
9, 1.11753, 1, 0, 0.500876,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485402,-99) , 
5, 304.706, 1, 0, 0.499678,-99) , 
11, 2.93282, 1, 0, 0.501185,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0109602);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.194611, 0, 1, 0.507223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497303,-99) , 
10, 2.80277, 1, 0, 0.500899,-99) , 
8, 1.14878, 0, 0, 0.502619,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492404,-99) , 
10, 4.51226, 1, 0, 0.502102,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.00643971);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509655,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510371,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499235,-99) , 
4, -0.930071, 1, 0, 0.501147,-99) , 
11, 2.44745, 1, 0, 0.501762,-99) , 
5, 131.111, 1, 0, 0.502291,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0113913);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.76471, 1, 1, 0.511906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499872,-99) , 
1, 170.006, 1, 0, 0.506667,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497273,-99) , 
9, 2.27416, 0, 0, 0.505783,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496286,-99) , 
1, 221.166, 0, 0, 0.500466,-99) , 
10, 3.51413, 0, 0, 0.501654,-99) , 
3, 0.319395, 0, 0, 0.502636,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.00791153);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 136.127, 1, 1, 0.503724,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493687,-99) , 
6, 163.31, 1, 0, 0.497507,-99) , 
9, 2.80159, 1, 0, 0.502746,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.00536988);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508503,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498947,-99) , 
9, 1.12087, 1, 0, 0.500063,-99) , 
4, 2.08727, 0, 0, 0.50065,-99) , 
1, 129.539, 1, 0, 0.501147,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.007892);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.15839, 0, 1, 0.505634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496903,-99) , 
9, 2.73793, 1, 0, 0.504124,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507951,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492726,-99) , 
11, 2.8517, 0, 0, 0.499413,-99) , 
8, -2.12575, 1, 0, 0.500214,-99) , 
3, 0.171075, 0, 0, 0.501765,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0100956);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492833,-99) , 
1, 229.699, 1, 0, 0.500068,-99) , 
6, 204.853, 0, 0, 0.504304,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50274,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495545,-99) , 
7, 190.559, 1, 0, 0.500601,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486073,-99) , 
3, -0.273885, 0, 0, 0.499396,-99) , 
11, 2.93282, 1, 0, 0.500539,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0130117);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49902,-99) , 
7, 143.365, 0, 0, 0.506029,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495263,-99) , 
11, 3.0671, 1, 0, 0.497954,-99) , 
11, 2.97904, 1, 0, 0.500524,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487553,-99) , 
2, 0.111564, 1, 0, 0.494386,-99) , 
11, 3.90357, 1, 0, 0.499699,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.00887171);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.70874, 1, 1, 0.510025,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49847,-99) , 
4, 1.21134, 0, 0, 0.500445,-99) , 
10, 3.44415, 0, 0, 0.502271,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486755,-99) , 
10, 4.0132, 1, 0, 0.494711,-99) , 
11, 3.90357, 1, 0, 0.501256,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.00981636);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.83816, 0, 1, 0.507679,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50216,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488924,-99) , 
5, 266.118, 1, 0, 0.500622,-99) , 
11, 2.97904, 1, 0, 0.502868,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48941,-99) , 
9, 2.32404, 0, 0, 0.494362,-99) , 
11, 3.90357, 1, 0, 0.501725,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.00962136);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49825,-99) , 
11, 2.83816, 0, 0, 0.505225,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506457,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497113,-99) , 
11, 3.0671, 1, 0, 0.498738,-99) , 
11, 2.97904, 1, 0, 0.500803,-99) , 
NN(
0, 
0, 
-1, 4.0132, 1, -1, 0.494777,-99) , 
11, 3.90357, 1, 0, 0.499993,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0081909);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51786,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494893,-99) , 
0, 107.594, 0, 0, 0.506926,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499826,-99) , 
4, 0.398993, 0, 0, 0.502095,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501031,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484443,-99) , 
3, -0.0267161, 0, 0, 0.495303,-99) , 
4, 1.33293, 1, 0, 0.500698,-99) , 
3, 0.393555, 0, 0, 0.501403,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.00903236);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.02033, 1, 1, 0.50301,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495105,-99) , 
2, 0.218261, 0, 0, 0.503727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487929,-99) , 
3, 0.0133916, 0, 0, 0.497925,-99) , 
4, 1.33293, 1, 0, 0.501982,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00624091);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507055,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508316,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502925,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49776,-99) , 
4, -0.930071, 1, 0, 0.499324,-99) , 
5, 131.111, 1, 0, 0.499922,-99) , 
11, 2.44745, 1, 0, 0.500401,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.00590991);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495671,-99) , 
0, 107.594, 0, 0, 0.505418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494506,-99) , 
11, 2.8517, 0, 0, 0.499446,-99) , 
3, -0.326873, 1, 0, 0.500137,-99) , 
3, 0.393555, 0, 0, 0.500735,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.00701679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5128,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497149,-99) , 
0, 107.594, 0, 0, 0.505348,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507006,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497798,-99) , 
10, 1.9956, 1, 0, 0.498544,-99) , 
3, -0.326873, 1, 0, 0.499191,-99) , 
3, 0.393555, 0, 0, 0.499888,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.00947751);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 143.365, 0, 1, 0.506229,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50466,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496226,-99) , 
11, 3.28722, 0, 0, 0.499537,-99) , 
11, 2.97904, 1, 0, 0.501667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490545,-99) , 
10, 4.0132, 1, 0, 0.496424,-99) , 
11, 3.90357, 1, 0, 0.500962,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00733861);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519854,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499646,-99) , 
2, 0.260398, 0, 0, 0.504884,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498351,-99) , 
11, 2.60924, 1, 0, 0.499681,-99) , 
4, 0.843849, 0, 0, 0.50126,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491884,-99) , 
2, 0.111564, 1, 0, 0.496052,-99) , 
11, 3.90357, 1, 0, 0.50056,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.00688138);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51831,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498839,-99) , 
10, 3.70874, 1, 0, 0.507263,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499626,-99) , 
3, 0.319395, 0, 0, 0.501413,-99) , 
10, 3.44415, 0, 0, 0.502528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492918,-99) , 
6, 191.425, 0, 0, 0.496234,-99) , 
11, 3.90357, 1, 0, 0.501683,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.00829262);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.260398, 0, 1, 0.506732,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499139,-99) , 
4, -0.864756, 1, 0, 0.501997,-99) , 
4, 0.843849, 0, 0, 0.503434,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493186,-99) , 
9, 2.32404, 0, 0, 0.496532,-99) , 
11, 3.90357, 1, 0, 0.502507,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0069717);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.918, 0, 1, 0.503584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496847,-99) , 
9, 2.97903, 1, 0, 0.502944,-99) , 
NN(
0, 
0, 
-1, 188.047, 0, -1, 0.496882,-99) , 
11, 3.90357, 1, 0, 0.50213,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
